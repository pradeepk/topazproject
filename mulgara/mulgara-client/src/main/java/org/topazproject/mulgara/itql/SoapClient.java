/* $HeadURL::                                                                             $
 * $Id$
 *
 * Copyright (c) 2006-2008 by Topaz, Inc.
 * http://topazproject.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.topazproject.mulgara.itql;

import java.io.IOException;
import java.lang.ref.WeakReference;
import java.net.MalformedURLException;
import java.net.URI;
import java.rmi.RemoteException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.transaction.xa.XAResource;
import javax.xml.rpc.ServiceException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.topazproject.mulgara.itql.service.ItqlInterpreterBean;
import org.topazproject.mulgara.itql.service.ItqlInterpreterBeanServiceLocator;
import org.topazproject.mulgara.itql.service.ItqlInterpreterException;
import org.topazproject.mulgara.itql.service.QueryException;

/** 
 * A mulgara client using SOAP. This is a thin wrapper around ItqlInterpreterBean.
 *
 * <p>The org.topazproject.mulgara.itql.service classes are generated by wsdl2java after
 * java2wsdl is run on the
 * {@link org.mulgara.itql.ItqlInterpreterBean org.mulgara.itql.ItqlInterpreterBean} class.
 *
 * @author Ronald Tschal√§r
 * @see org.mulgara.itql.ItqlInterpreterBean
 */
public class SoapClient implements ItqlClient {
  private static final Log                 log            = LogFactory.getLog(SoapClient.class);
  private static final List<BeanReference> instanceList   = new LinkedList<BeanReference>();

  private final ItqlInterpreterBean interpreter;
  private final Map<String, String> aliases = new HashMap<String, String>();
  private       BeanReference       cleanupRef;
  private       boolean             inTransaction = false;
  private       Exception           lastError = null;

  static {
    Runtime.getRuntime().addShutdownHook(new Thread() {
      public void run() {
        synchronized (instanceList) {
          for (BeanReference ref : instanceList) {
            try {
              ref.interpreter.close();
            } catch (Throwable t) {
            }
          }
        }
      }
    });
  }

  /** 
   * This registers the SoapClient instance so we can close the underlying ItqlInterpreterBean
   * session when it is gc'd or when the app exits.
   */
  private static void registerInstance(SoapClient inst) {
    synchronized (instanceList) {
      // first some housekeeping: clean up gc'd instances
      for (Iterator<BeanReference> iter = instanceList.iterator(); iter.hasNext(); ) {
        BeanReference ref = iter.next();
        if (ref.get() == null) {
          iter.remove();
          try {
            ref.interpreter.close();
          } catch (Throwable t) {
            if (log.isDebugEnabled())
              log.debug("Error closing interpreter instance", t);
          }
          ref.interpreter = null;
        }
      }

      // register it
      instanceList.add(inst.cleanupRef = new BeanReference(inst));
    }
  }

  /** 
   * This keeps a reference to the underlying ItqlInterpreterBean instance.
   */
  private static class BeanReference extends WeakReference {
    ItqlInterpreterBean interpreter;

    BeanReference(SoapClient client) {
      super(client);
      interpreter = client.interpreter;
    }
  }

  /** 
   * Create a new instance pointed at the given database.
   * 
   * @param database  the url of the database web-service
   * @throws MalformedURLException if <var>database</var> is not a valid URL
   * @throws ServiceException if an error occurred locating the web-service
   * @throws RemoteException if an error occurred talking to the web-service
   */
  public SoapClient(URI database) throws MalformedURLException, ServiceException, RemoteException {
    ItqlInterpreterBeanServiceLocator locator = new ItqlInterpreterBeanServiceLocator();
    locator.setMaintainSession(true);
    interpreter = locator.getItqlInterpreterBeanServicePort(database.toURL());
    registerInstance(this);
  }

  private String unalias(String itql) {
    /* Ideally we would send a bunch of iTQL alias commands. However, those are local to an
     * ItqlInterpreter instance, which in turn is bound to a (http) session. The problem is
     * that if there is a long period of inactivity that causes the server to time-out the
     * session, then the ItqlInterpreter instance goes away and a new is created, meaning we
     * loose the aliases. If we could easily detect this case then that wouldn't be a problem,
     * but I know of no way to do so.
     *
     * Hence we do the aliases locally. It's a bit of a hack, since we don't truly parse the
     * iTQL, but it seems to work for most cases.
     */
    for (Map.Entry<String, String> e : aliases.entrySet()) {
      String alias = e.getKey();
      String uri   = e.getValue();
      itql = itql.replaceAll("<" + alias + ":", "<" + uri)
                 .replaceAll("\\^\\^" + alias + ":([^\\s;]+)", "^^<" + uri + "$1>");
    }

    return itql;
  }

  public List<Answer> doQuery(String itql) throws IOException, AnswerException {
    try {
      itql = unalias(itql);

      if (log.isDebugEnabled())
        log.debug("sending query '" + itql + "'");

      String xml = interpreter.executeQueryToString(itql);

      if (log.isDebugEnabled())
        log.debug("got result '" + xml + "'");

      return XmlAnswer.parseAnswer(xml);
    } catch (ItqlInterpreterException e) {
      lastError = e;
      throw (IOException) new IOException().initCause(e);
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    }
  }

  public void doUpdate(String itql) throws IOException {
    try {
      itql = unalias(itql);

      if (log.isDebugEnabled())
        log.debug("sending update '" + itql + "'");

      interpreter.executeUpdate(itql);
    } catch (ItqlInterpreterException e) {
      lastError = e;
      throw (IOException) new IOException().initCause(e);
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    }
  }

  public void beginTxn(String txnName) throws IOException {
    if (log.isDebugEnabled())
      log.debug("sending beginTransaction '" + txnName + "'");

    try {
      interpreter.beginTransaction(txnName);
      inTransaction = true;
    } catch (QueryException e) {
      lastError = e;
      throw (IOException) new IOException().initCause(e);
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    }
  }

  public void commitTxn(String txnName) throws IOException {
    if (log.isDebugEnabled())
      log.debug("sending commit '" + txnName + "'");

    try {
      interpreter.commit(txnName);
    } catch (QueryException e) {
      lastError = e;
      throw (IOException) new IOException().initCause(e);
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    } finally {
      // hmm, this may not be true if we failed to talk to the server
      inTransaction = false;
    }
  }

  public void rollbackTxn(String txnName) throws IOException {
    if (log.isDebugEnabled())
      log.debug("sending rollback '" + txnName + "'");

    try {
      interpreter.rollback(txnName);
      inTransaction = false;
    } catch (QueryException e) {
      lastError = e;
      throw (IOException) new IOException().initCause(e);
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    } finally {
      if (inTransaction) {
        try {
          interpreter.commit(txnName);  // this always resets the transaction
        } catch (Exception e) {
          log.error("Error resetting session", e);
        } finally {
          // hmm, this may not be true if we failed to talk to the server
          inTransaction = false;
        }
      }
    }
  }

  public XAResource getXAResource() {
    throw new UnsupportedOperationException();
  }

  public XAResource getReadOnlyXAResource() {
    throw new UnsupportedOperationException();
  }

  /**
   * Returns the current transaction state.
   * 
   * @return true if a transaction is active, false otherwise
   */
  public boolean isInTransaction() {
    return inTransaction;
  }

  public void setAliases(Map<String, String> aliases) {
    this.aliases.clear();
    this.aliases.putAll(aliases);
  }

  public Map<String, String> getAliases() {
    return new HashMap<String, String>(aliases);
  }

  public void ping() throws IOException {
    try {
      interpreter.executeQueryToString("");
    } catch (ItqlInterpreterException iie) {
      lastError = iie;
      throw (IOException) new IOException("Error pinging server").initCause(iie);
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    }
  }

  public Exception getLastError() {
    return lastError;
  }

  public void clearLastError() {
    lastError = null;
  }

  public void close() {
    boolean wasActive;
    synchronized (instanceList) {
      wasActive = instanceList.remove(cleanupRef);
    }

    if (wasActive) {
      try {
        interpreter.close();
      } catch (RemoteException e) {
        log.error("Error closing session", e);
      }
    }
  }
}
