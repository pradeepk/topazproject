/* $HeadURL::                                                                             $
 * $Id$
 *
 * Copyright (c) 2006 by Topaz, Inc.
 * http://topazproject.org
 *
 * Licensed under the Educational Community License version 1.0
 * http://opensource.org/licenses/ecl1.php
 */

package org.topazproject.mulgara.itql;

import java.lang.ref.WeakReference;

import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;

import java.text.SimpleDateFormat;

import java.rmi.RemoteException;

import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.SimpleTimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.rpc.ServiceException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.topazproject.mulgara.itql.service.ItqlInterpreterBean;
import org.topazproject.mulgara.itql.service.ItqlInterpreterBeanServiceLocator;
import org.topazproject.mulgara.itql.service.ItqlInterpreterException;
import org.topazproject.mulgara.itql.service.QueryException;

/** 
 * A simple helper for Itql commands. This is a thin wrapper around ItqlInterpreterBean.
 * <p>
 * (The org.topazproject.mulgara.itql.service classes are generated by wsdl2java after
 * java2wsdl is run on the
 * {@link org.kowari.itql.ItqlInterpreterBean org.kowari.itql.ItqlInterpreterBean} class.)
 *
 * @author Ronald Tschal√§r
 * @see org.kowari.itql.ItqlInterpreterBean
 */
public class ItqlHelper {
  private static final Log     log = LogFactory.getLog(ItqlHelper.class);
  private static final HashMap defaultAliases = new HashMap();
  private static final List    instanceList   = new LinkedList();

  /** The base URI for rdf defined URIs: {@value} */
  public static final String RDF_URI      = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  /** The base URI for rdf-schema defined URIs: {@value} */
  public static final String RDFS_URI     = "http://www.w3.org/2000/01/rdf-schema#";
  /** The base URI for owl defined URIs: {@value} */
  public static final String OWL_URI      = "http://www.w3.org/2002/07/owl#";
  /** The base URI for xml-schema defined URIs: {@value} */
  public static final String XSD_URI      = "http://www.w3.org/2001/XMLSchema#";
  /** The base URI for tucana defined URIs: {@value} */
  public static final String TUCANA_URI   = "http://mulgara.org/mulgara#";
  /** The base URI for dublin-core defined URIs: {@value} */
  public static final String DC_URI       = "http://purl.org/dc/elements/1.1/";
  /** The base URI for dublin-core terms URIs: {@value} */
  public static final String DC_TERMS_URI = "http://purl.org/dc/terms/";
  /** The base URI for oai-dublin-core defined URIs: {@value} */
  public static final String OAI_DC_URI   = "http://www.openarchives.org/OAI/2.0/oai_dc/";
  /** The base URI for fedora defined URIs: {@value} */
  public static final String FEDORA_URI   = "info:fedora/";
  /** The base URI for topaz defined URIs: {@value} */
  public static final String TOPAZ_URI    = "http://rdf.topazproject.org/RDF/";

  private final ItqlInterpreterBean interpreter;
  private       BeanReference       cleanupRef;
  private       boolean             inTransaction = false;
  private       Exception           lastError = null;

  static {
    defaultAliases.put("rdf",      RDF_URI);
    defaultAliases.put("rdfs",     RDFS_URI);
    defaultAliases.put("owl",      OWL_URI);
    defaultAliases.put("xsd",      XSD_URI);
    defaultAliases.put("tucana",   TUCANA_URI);
    defaultAliases.put("dc",       DC_URI);
    defaultAliases.put("dc_terms", DC_TERMS_URI);
    defaultAliases.put("oai_dc",   OAI_DC_URI);
    defaultAliases.put("fedora",   FEDORA_URI);
    defaultAliases.put("topaz",    TOPAZ_URI);

    Runtime.getRuntime().addShutdownHook(new Thread() {
      public void run() {
        synchronized (instanceList) {
          for (Iterator iter = instanceList.iterator(); iter.hasNext(); ) {
            BeanReference ref = (BeanReference) iter.next();
            try {
              ref.interpreter.close();
            } catch (Throwable t) {
            }
          }
        }
      }
    });
  }

  /** 
   * This registers the ItqlHelper instance so we can close the underlying ItqlInterpreterBean
   * session when it is gc'd or when the app exits.
   */
  private static void registerInstance(ItqlHelper inst) {
    synchronized (instanceList) {
      // first some housekeeping: clean up gc'd instances
      for (Iterator iter = instanceList.iterator(); iter.hasNext(); ) {
        BeanReference ref = (BeanReference) iter.next();
        if (ref.get() == null) {
          iter.remove();
          try {
            ref.interpreter.close();
          } catch (Throwable t) {
            if (log.isDebugEnabled())
              log.debug("Error closing interpreter instance", t);
          }
          ref.interpreter = null;
        }
      }

      // register it
      instanceList.add(inst.cleanupRef = new BeanReference(inst));
    }
  }

  /** 
   * This keeps a reference to the underlying ItqlInterpreterBean instance.
   */
  private static class BeanReference extends WeakReference {
    ItqlInterpreterBean interpreter;

    BeanReference(ItqlHelper helper) {
      super(helper);
      interpreter = helper.interpreter;
    }
  }

  /** 
   * Create a new instance pointed at the given database. The instance is initialized with the
   * default set of aliases.
   * 
   * @param database  the url of the database web-service
   * @throws MalformedURLException if <var>database</var> is not a valid URL
   * @throws ServiceException if an error occurred locating the web-service
   * @throws RemoteException if an error occurred talking to the web-service
   */
  public ItqlHelper(URI database) throws MalformedURLException, ServiceException, RemoteException {
    ItqlInterpreterBeanServiceLocator locator = new ItqlInterpreterBeanServiceLocator();
    locator.setMaintainSession(true);
    interpreter = locator.getItqlInterpreterBeanServicePort(database.toURL());
    registerInstance(this);
  }

  /**
   * Get a copy of the default aliases.
   *
   * @return the default aliases
   */
  public static Map getDefaultAliases() {
    return new HashMap(defaultAliases);
  }

  private String unalias(String itql, Map aliases) {
    /* Ideally we would send a bunch of iTQL alias commands. However, those are local to an
     * ItqlInterpreter instance, which in turn is bound to a (http) session. The problem is
     * that if there is a long period of inactivity that causes the server to time-out the
     * session, then the ItqlInterpreter instance goes away and a new is created, meaning we
     * loose the aliases. If we could easily detect this case then that wouldn't be a problem,
     * but I know of no way to do so.
     *
     * Hence we do the aliases locally. It's a bit of a hack, since we don't truly parse the
     * iTQL, but it seems to work for most cases.
     */
    for (Iterator iter = aliases.keySet().iterator(); iter.hasNext(); ) {
      String alias = (String) iter.next();
      String uri   = (String) aliases.get(alias);
      itql = itql.replaceAll("<" + alias + ":", "<" + uri)
                 .replaceAll("\\^\\^" + alias + ":([^\\s;]+)", "^^<" + uri + "$1>");
    }

    return itql;
  }

  /** 
   * Run one or more iTQL queries. 
   * 
   * @param itql the iTQL query/queries to run
   * @param aliases the aliases to use or <code>null</code> for default; 
   *                keys and values must be {@link java.lang.String String}'s
   * @return the answer as an XML string; use one of the Answer classes to parse it
   * @throws ItqlInterpreterException if an exception was encountered while processing the queries
   * @throws RemoteException if an exception occurred talking to the service
   */
  public String doQuery(String itql, Map aliases) throws ItqlInterpreterException, RemoteException {
    try {
      if (aliases == null)
        aliases = defaultAliases;

      itql = unalias(itql, aliases);
      if (!itql.trim().endsWith(";"))
        itql += ";";

      if (log.isDebugEnabled())
        log.debug("sending query '" + itql + "'");

      String xml = interpreter.executeQueryToString(itql);

      if (log.isDebugEnabled())
        log.debug("got result '" + xml + "'");

      return xml;
    } catch (ItqlInterpreterException e) {
      lastError = e;
      throw e;
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    }
  }

  /** 
   * Run one or more iTQL update commands (or any commands that do not produce output).
   * 
   * @param itql the iTQL statement(s) to execute
   * @param aliases the aliases to use or <code>null</code> for default; 
   *                keys and values must be {@link java.lang.String String}'s
   * @throws ItqlInterpreterException if an exception was encountered while processing the queries
   * @throws RemoteException if an exception occurred talking to the service
   */
  public void doUpdate(String itql, Map aliases) throws ItqlInterpreterException, RemoteException {
    try {
      if (aliases == null)
        aliases = defaultAliases;

      itql = unalias(itql, aliases);
      if (!itql.trim().endsWith(";"))
        itql += ";";

      if (log.isDebugEnabled())
        log.debug("sending update '" + itql + "'");

      interpreter.executeUpdate(itql);
    } catch (ItqlInterpreterException e) {
      lastError = e;
      throw e;
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    }
  }

  /** 
   * Begin a transaction. If not invoked, iTQL commands will run in auto-commit mode.
   * One of {@link #commitTxn commitTxn()} or {@link #rollbackTxn rollbackTxn()} must be
   * invoked to end the transaction.
   * 
   * @param txnName  a name to associate with the transaction; used for logging only
   * @throws QueryException if an exception occurred starting the transaction
   * @throws RemoteException if an exception occurred talking to the service
   */
  public void beginTxn(String txnName) throws QueryException, RemoteException {
    if (log.isDebugEnabled())
      log.debug("sending beginTransaction '" + txnName + "'");

    try {
      interpreter.beginTransaction(txnName);
      inTransaction = true;
    } catch (QueryException e) {
      lastError = e;
      throw e;
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    }
  }

  /** 
   * Commit a transaction. May only be invoked after a {@link #beginTxn beginTxn()}.
   * 
   * @param txnName  a name to associate with the transaction; used for logging only
   * @throws QueryException if an exception occurred committing the transaction
   * @throws RemoteException if an exception occurred talking to the service
   */
  public void commitTxn(String txnName) throws QueryException, RemoteException {
    if (log.isDebugEnabled())
      log.debug("sending commit '" + txnName + "'");

    try {
      interpreter.commit(txnName);
    } catch (QueryException e) {
      lastError = e;
      throw e;
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    } finally {
      // hmm, this may not be true if we failed to talk to the server
      inTransaction = false;
    }
  }

  /** 
   * Roll back a transaction. May only be invoked after a {@link #beginTxn beginTxn()}.
   * 
   * @param txnName  a name to associate with the transaction; used for logging only
   * @throws QueryException if an exception occurred rolling back the transaction
   * @throws RemoteException if an exception occurred talking to the service
   */
  public void rollbackTxn(String txnName) throws QueryException, RemoteException {
    if (log.isDebugEnabled())
      log.debug("sending rollback '" + txnName + "'");

    try {
      interpreter.rollback(txnName);
      inTransaction = false;
    } catch (QueryException e) {
      lastError = e;
      throw e;
    } catch (RemoteException e) {
      lastError = e;
      throw e;
    } finally {
      if (inTransaction) {
        try {
          interpreter.commit(txnName);  // this always resets the transaction
        } catch (Exception e) {
          log.error("Error resetting session", e);
        } finally {
          // hmm, this may not be true if we failed to talk to the server
          inTransaction = false;
        }
      }
    }
  }

  /**
   * Returns the current transaction state.
   * 
   * @return true if a transaction is active, false otherwise
   */
  public boolean isInTransaction() {
    return inTransaction;
  }

  /**
   * Returns the last error from a mulgara operation.
   * 
   * @return the error or null
   */
  public Exception getLastError() {
    return lastError;
  }

  /**
   * Clear the error status from a mulgara operation.
   * 
   */
  public void clearLastError() {
    lastError = null;
  }

  /** 
   * Close the session. 
   * 
   * @throws RemoteException if an exception occurred talking to the service
   */
  public void close() throws RemoteException {
    boolean wasActive;
    synchronized (instanceList) {
      wasActive = instanceList.remove(cleanupRef);
    }

    if (wasActive)
      interpreter.close();
  }
}
